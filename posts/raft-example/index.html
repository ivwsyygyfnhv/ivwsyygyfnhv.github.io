<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		
		
		<meta name="generator" content="Hugo 0.44" />
		<title>raft-example学习笔记 &middot; 4 Fish</title>
		<link rel="shortcut icon" href="https://4fish.xyz/images/favicon.ico">
		<link rel="stylesheet" href="https://4fish.xyz/css/style.css">
		<link rel="stylesheet" href="https://4fish.xyz/css/highlight.css">

		
		<link rel="stylesheet" href="https://4fish.xyz/css/monosocialiconsfont.css">
		

		
		<link href="https://4fish.xyz/index.xml" rel="alternate" type="application/rss+xml" title="4 Fish" />
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://4fish.xyz/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://4fish.xyz/posts'>Archive</a>
	<a href='https://4fish.xyz/tags'>Tags</a>
	<a href='https://4fish.xyz/about'>About</a>

	

	
	<a class="cta" href="https://4fish.xyz/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        raft-example学习笔记
                    </h1>
                    <h2 class="headline">
                    Jan 21, 2019 14:08
                    · 3475 words
                    · 7 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://4fish.xyz/tags/raft">raft</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    <p><a href="https://github.com/etcd-io/etcd/tree/master/contrib/raftexample">raft-example</a>是etcd中raft库的一个实现示例，它包含了etcd raft库的基本用法，以及如何利用它来实现一个简单的支持HTTP API的KV存储数据库。</p>

<p>首先来看这个应用的目录结构：</p>

<pre><code class="language-text">.
├── Procfile
├── README.md
├── doc.go
├── httpapi.go
├── kvstore.go
├── kvstore_test.go
├── listener.go
├── main.go
├── raft.go
├── raftexample
└── raftexample_test.go
</code></pre>

<p>其中<code>main.go</code>是应用的主入口，它会解析命令行参数，初始化raft节点实例，以及启动和提供HTTP API服务；<code>httpapi.go</code>中包含了这个kv存储系统的HTTP API的处理函数实现；<code>kvstore.go</code>中则提供了kv数据库与raft节点之间交互的桥梁，包括把更新状态同步传输到其他raft节点上，以及从raft状态机中读取提交已消息应用在kv字典上，读取快照载入等等；<code>raft.go</code>中包含了raft节点的实现，它封装了与底层raft协议通信的方法，以及包含消息接收，WAL写入，快照同步，节点变更等的处理，对于应用来说只需去关心这个raft节点提供的事件通道（通过channel来收发）进行状态同步即可。</p>

<p>首先看主入口<code>main.go</code>的实现：</p>

<pre><code class="language-go">func main() {
	//...

	proposeC := make(chan string)
	defer close(proposeC)
	confChangeC := make(chan raftpb.ConfChange)
	defer close(confChangeC)

	// raft provides a commit stream for the proposals from the http api
	var kvs *kvstore
	getSnapshot := func() ([]byte, error) { return kvs.getSnapshot() }
	commitC, errorC, snapshotterReady := newRaftNode(*id, strings.Split(*cluster, &quot;,&quot;), *join, getSnapshot, proposeC, confChangeC)

	kvs = newKVStore(&lt;-snapshotterReady, proposeC, commitC, errorC)

	// the key-value http handler will propose updates to raft
	serveHttpKVAPI(kvs, *kvport, confChangeC, errorC)
}
</code></pre>

<p>略过了前面的一些参数解析的代码，它首先创建了两个channel：<code>proposeC</code>和<code>confChangeC</code>，接着根据传入参数来建立一个raft节点实例，构造函数会返回三个channel：<code>commitC</code>，<code>errorC</code>和<code>confChangeC</code>，这些channel在下面会作为参数来传入kv存储的构造函数，这些channel会作为消息通道来完成应用与raft节点之间的消息传递，后面会提到。</p>

<p>再来看<code>raft.go</code>中<code>newRaftNode</code>的实现：</p>

<pre><code class="language-go">func newRaftNode(id int, peers []string, join bool, getSnapshot func() ([]byte, error), proposeC &lt;-chan string,
	confChangeC &lt;-chan raftpb.ConfChange) (&lt;-chan *string, &lt;-chan error, &lt;-chan *snap.Snapshotter) {

	commitC := make(chan *string)
	errorC := make(chan error)

	rc := &amp;raftNode{
		proposeC:    proposeC,
		confChangeC: confChangeC,
		commitC:     commitC,
		errorC:      errorC,
		id:          id,
		peers:       peers,
		join:        join,
		waldir:      fmt.Sprintf(&quot;raftexample-%d&quot;, id),
		snapdir:     fmt.Sprintf(&quot;raftexample-%d-snap&quot;, id),
		getSnapshot: getSnapshot,
		snapCount:   defaultSnapshotCount,
		stopc:       make(chan struct{}),
		httpstopc:   make(chan struct{}),
		httpdonec:   make(chan struct{}),

		snapshotterReady: make(chan *snap.Snapshotter, 1),
		// rest of structure populated after WAL replay
	}
	go rc.startRaft()
	return commitC, errorC, rc.snapshotterReady
}
</code></pre>

<p>这个函数接收6个参数：</p>

<ul>
<li>id：raft节点的唯一标识。</li>
<li>peers：raft集群节点的列表。</li>
<li>join：标识raft节点是否正在加入一个已在集群。</li>
<li>getSnapshot：获取应用状态机快照的函数，由应用来提供。</li>
<li>proposeC：接收应用发来的提案消息（kv更新）的通道。</li>
<li>confChangeC：接收集群配置变更消息的通道。</li>
</ul>

<p>函数会返回两个关键变量：</p>

<ul>
<li>commitC：用来通知应用准备提交的通道。</li>
<li>errorC：接收raft节点错误的通道。</li>
</ul>

<p>然后看<code>startRaft()</code>方法的实现：</p>

<pre><code class="language-go">func (rc *raftNode) replayWAL() *wal.WAL {
	log.Printf(&quot;replaying WAL of member %d&quot;, rc.id)
	snapshot := rc.loadSnapshot()
	w := rc.openWAL(snapshot)
	_, st, ents, err := w.ReadAll()
	if err != nil {
		log.Fatalf(&quot;raftexample: failed to read WAL (%v)&quot;, err)
	}
	rc.raftStorage = raft.NewMemoryStorage()
	if snapshot != nil {
		rc.raftStorage.ApplySnapshot(*snapshot)
	}
	rc.raftStorage.SetHardState(st)

	// append to storage so raft starts at the right place in log
	rc.raftStorage.Append(ents)
	// send nil once lastIndex is published so client knows commit channel is current
	if len(ents) &gt; 0 {
		rc.lastIndex = ents[len(ents)-1].Index
	} else {
		rc.commitC &lt;- nil
	}
	return w
}

func (rc *raftNode) startRaft() {
	if !fileutil.Exist(rc.snapdir) {
		if err := os.Mkdir(rc.snapdir, 0750); err != nil {
			log.Fatalf(&quot;raftexample: cannot create dir for snapshot (%v)&quot;, err)
		}
	}
	rc.snapshotter = snap.New(zap.NewExample(), rc.snapdir)
	rc.snapshotterReady &lt;- rc.snapshotter

	oldwal := wal.Exist(rc.waldir)
	rc.wal = rc.replayWAL()

	rpeers := make([]raft.Peer, len(rc.peers))
	for i := range rpeers {
		rpeers[i] = raft.Peer{ID: uint64(i + 1)}
	}
	c := &amp;raft.Config{
		ID:                        uint64(rc.id),
		ElectionTick:              10,
		HeartbeatTick:             1,
		Storage:                   rc.raftStorage,
		MaxSizePerMsg:             1024 * 1024,
		MaxInflightMsgs:           256,
		MaxUncommittedEntriesSize: 1 &lt;&lt; 30,
	}

	if oldwal {
		rc.node = raft.RestartNode(c)
	} else {
		startPeers := rpeers
		if rc.join {
			startPeers = nil
		}
		rc.node = raft.StartNode(c, startPeers)
	}

	rc.transport = &amp;rafthttp.Transport{
		Logger:      zap.NewExample(),
		ID:          types.ID(rc.id),
		ClusterID:   0x1000,
		Raft:        rc,
		ServerStats: stats.NewServerStats(&quot;&quot;, &quot;&quot;),
		LeaderStats: stats.NewLeaderStats(strconv.Itoa(rc.id)),
		ErrorC:      make(chan error),
	}

	rc.transport.Start()
	for i := range rc.peers {
		if i+1 != rc.id {
			rc.transport.AddPeer(types.ID(i+1), []string{rc.peers[i]})
		}
	}

	go rc.serveRaft()
	go rc.serveChannels()
}
</code></pre>

<p>这个方法主要实现了以下几个步骤：</p>

<ol>
<li>重放WAL日志，首先检查是否有可用快照，将快照应用到raft内存状态机中，然后读取快照之后插入的日志进行同步，并更新raft节点<code>lastIndex</code>（日志中最后一条entry的索引值），这个步骤还会设置当前raft当前的状态（Term，Commit Index等）。</li>
<li>完成日志重放后，初始化raft配置（包括刚刚与WAL同步的内存状态机），让raft协议启动或重启一个新的节点，配置并初始化raft的传输通道。</li>
<li>启动后台运行的goroutine，这个goroutine会持续监听来自底层raft的事件和状态变更，以及处理来自应用的更新提案。</li>
</ol>

<p><code>serveChannels()</code>方法比较长，因此分成了几个部分。</p>

<pre><code class="language-go">snap, err := rc.raftStorage.Snapshot()
if err != nil {
    panic(err)
}
rc.confState = snap.Metadata.ConfState
rc.snapshotIndex = snap.Metadata.Index
rc.appliedIndex = snap.Metadata.Index
</code></pre>

<p>这个方法首先会获取raft内存状态机的快照信息，并把快照中的几个状态同步到raft节点自身上，其中<code>appliedIndex</code>即为最后应用到状态机中的日志索引位置（它被初始化为snapshot index，因为状态机要从这个位置开始同步）。</p>

<pre><code class="language-go">// send proposals over raft
go func() {
	confChangeCount := uint64(0)

	for rc.proposeC != nil &amp;&amp; rc.confChangeC != nil {
		select {
		case prop, ok := &lt;-rc.proposeC:
			if !ok {
				rc.proposeC = nil
			} else {
				// blocks until accepted by raft state machine
				rc.node.Propose(context.TODO(), []byte(prop))
			}

		case cc, ok := &lt;-rc.confChangeC:
			if !ok {
				rc.confChangeC = nil
			} else {
				confChangeCount++
				cc.ID = confChangeCount
				rc.node.ProposeConfChange(context.TODO(), cc)
			}
		}
	}
	// client closed channel; shutdown raft if not already
	close(rc.stopc)
}()
</code></pre>

<p>接下来这部分则实现了从应用端接收提案请求（<code>proposeC</code>），并将指令提交到raft协议上，以及类似地，接收配置变更请求并提交到raft上。</p>

<pre><code class="language-go">// event loop on raft state machine updates
for {
	select {
	case &lt;-ticker.C:
		rc.node.Tick()

	// store raft entries to wal, then publish over commit channel
	case rd := &lt;-rc.node.Ready():
		rc.wal.Save(rd.HardState, rd.Entries)
		if !raft.IsEmptySnap(rd.Snapshot) {
			rc.saveSnap(rd.Snapshot)
			rc.raftStorage.ApplySnapshot(rd.Snapshot)
			rc.publishSnapshot(rd.Snapshot)
		}
		rc.raftStorage.Append(rd.Entries)
		rc.transport.Send(rd.Messages)
		if ok := rc.publishEntries(rc.entriesToApply(rd.CommittedEntries)); !ok {
			rc.stop()
			return
		}
		rc.maybeTriggerSnapshot()
		rc.node.Advance()

	case err := &lt;-rc.transport.ErrorC:
		rc.writeError(err)
		return

	case &lt;-rc.stopc:
		rc.stop()
		return
	}
}
</code></pre>

<p>最后程序会在一个主循环中处理消息事件，节点通过<code>Ready()</code>方法从通道中获取到Ready对象，raft节点做的事情就是把ready中的日志条目写到WAL中，检查ready中是否包括快照，若包括快照则把快照同步到自身以及应用的状态机中（分别对应<code>rc.raftStorage.ApplySnapshot(rd.Snapshot)</code>和<code>rc.publishSnapshot(rd.Snapshot)</code>），把消息发送到其他节点，接下来在<code>rc.publishEntries(rc.entriesToApply(rd.CommittedEntries))</code>这一步中，raft节点会把<code>appliedIndex</code>到<code>Commit Index</code>之间的日志提交到应用状态机上。</p>

<p>在<code>rc.maybeTriggerSnapshot()</code>这一步raft节点会检测<code>appliedIndex-snapshotIndex</code>的值是否大于快照的阈值（在这里是10000），如果是则调用应用提供的获取快照函数，把新的快照持久化到硬盘中，并将<code>snapshotIndex</code>设置为<code>appliedIndex</code>。</p>

<p>紧接着下一步调用<code>rc.node.Advance()</code>来通知raft节点当前的ready对象已经处理完成，准备好接收下一个可用的ready对象。</p>

<pre><code class="language-go">func (rc *raftNode) publishEntries(ents []raftpb.Entry) bool {
	for i := range ents {
		switch ents[i].Type {
		case raftpb.EntryNormal:
			if len(ents[i].Data) == 0 {
				break
			}
			s := string(ents[i].Data)
			select {
			case rc.commitC &lt;- &amp;s:
			case &lt;-rc.stopc:
				return false
			}

		case raftpb.EntryConfChange:
			//...
		}

		// after commit, update appliedIndex
		rc.appliedIndex = ents[i].Index

		// special nil commit to signal replay has finished
		if ents[i].Index == rc.lastIndex {
			select {
			case rc.commitC &lt;- nil:
			case &lt;-rc.stopc:
				return false
			}
		}
	}
	return true
}
</code></pre>

<p><code>publishEntries()</code>的逻辑如上，raft节点通过<code>commitC</code>把commit entry的数据同步到应用状态机，并更新<code>appliedIndex</code>的值，如果出现<code>ents[i].Index == rc.lastIndex</code>（<code>lastIndex</code>在之前提到，是初始化时最后一个日志条目的索引值），说明日志重放已经完成。</p>

<p>raft节点的逻辑基本已经过完了，接下来再从<code>kvstore.go</code>中观察kv数据库是如何跟raft节点进行状态同步的。</p>

<p>应用通过<code>newKVStore()</code>函数来构造一个<code>kvstore</code>对象：</p>

<pre><code class="language-go">func newKVStore(snapshotter *snap.Snapshotter, proposeC chan&lt;- string, commitC &lt;-chan *string, errorC &lt;-chan error) *kvstore {
	s := &amp;kvstore{proposeC: proposeC, kvStore: make(map[string]string), snapshotter: snapshotter}
	// replay log into key-value map
	s.readCommits(commitC, errorC)
	// read commits from raft into kvStore map until error
	go s.readCommits(commitC, errorC)
	return s
}

func (s *kvstore) readCommits(commitC &lt;-chan *string, errorC &lt;-chan error) {
	for data := range commitC {
		if data == nil {
			// done replaying log; new data incoming
			// OR signaled to load snapshot
			snapshot, err := s.snapshotter.Load()
			if err == snap.ErrNoSnapshot {
				return
			}
			if err != nil {
				log.Panic(err)
			}
			log.Printf(&quot;loading snapshot at term %d and index %d&quot;, snapshot.Metadata.Term, snapshot.Metadata.Index)
			if err := s.recoverFromSnapshot(snapshot.Data); err != nil {
				log.Panic(err)
			}
			continue
		}

		var dataKv kv
		dec := gob.NewDecoder(bytes.NewBufferString(*data))
		if err := dec.Decode(&amp;dataKv); err != nil {
			log.Fatalf(&quot;raftexample: could not decode message (%v)&quot;, err)
		}
		s.mu.Lock()
		s.kvStore[dataKv.Key] = dataKv.Val
		s.mu.Unlock()
	}
	if err, ok := &lt;-errorC; ok {
		log.Fatal(err)
	}
}
</code></pre>

<p>在<code>newKVStore()</code>里面，调用了<code>readCommits()</code>方法来同步提交日志，程序会不断从<code>commitC</code>通道中读取数据，当<code>data</code>为nil时代表一个特殊信号，说明raft节点已经完成日志回放了或者raft节点触发应用端来进行快照同步，为什么要进行两次<code>readCommits()</code>的调用？因为第一次需要进行日志回放（之前raft节点<code>publishEntries()</code>的实现中当<code>ents[i].Index == rc.lastIndex</code>时会发送nil到<code>commitC</code>），而第二次启动一个goroutine调用<code>readCommits()</code>来持续把提交日志应用到状态机上（实测当触发snapshot后程序会阻塞在第一个<code>readCommits</code>上，因为此时会一直卡在channel的读取上而不会退出，所以此处应该是有点问题的）。程序接收到数据后用解码器反序列化为kv对象，再把变更更新到<code>kvStore</code>这个map上面。</p>

<p>再回过头来看kv数据库读取和更新的实现，这时候便一目了然了：</p>

<pre><code class="language-go">func (s *kvstore) Lookup(key string) (string, bool) {
	s.mu.RLock()
	v, ok := s.kvStore[key]
	s.mu.RUnlock()
	return v, ok
}

func (s *kvstore) Propose(k string, v string) {
	var buf bytes.Buffer
	if err := gob.NewEncoder(&amp;buf).Encode(kv{k, v}); err != nil {
		log.Fatal(err)
	}
	s.proposeC &lt;- buf.String()
}
</code></pre>

                </section>
            </article>

            

            

            

            <footer id="footer">
    
    <p class="small">
    
       © Copyright 2019 <i class="fa fa-heart" aria-hidden="true"></i> 
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://4fish.xyz/js/jquery-3.3.1.min.js"></script>
<script src="https://4fish.xyz/js/main.js"></script>
<script src="https://4fish.xyz/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script>
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-117516487-1', 'auto');
	
	ga('send', 'pageview');
}
</script>





    </body>
</html>
